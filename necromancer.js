// necromancer botting solutions (target: fxp.co.il)
// DRAIN GANG SBE GBE HAUNTED MOUND GOTHMONEYRECORDS SHADOWWIZARDMONEYGANG

// ⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠶⠤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⠶⠲⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⢠⠉⠑⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠞⠁⡀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⢣⠀⠀⠙⢢⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠞⠁⠀⢠⡁⠀⠘⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⢀⡀⠀⠸⠀⠀⠀⢀⠏⣳⠴⣶⠶⠞⠛⠉⠉⠉⠓⠛⠒⠢⢄⡈⢏⠢⡀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡄⡀⠉⠑⠒⢒⡶⠚⢀⠵⠊⠀⠀⠀⠀⣀⡴⠦⠄⠀⠀⠀⠀⠀⠙⠢⡘⣆⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠳⡀⠀⣠⡔⠁⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠣⡱⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⡟⡼⣲⠿⣾⡅⢸⢀⠜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣆⠀⠀⠀⠱⡙⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢸⠇⡗⢲⣴⣟⣻⠃⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡦⡀⠀⢱⠘⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢸⠀⠉⡼⠁⠣⡀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⣧⡈⠢⡀⠣⠸⡆⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⣾⠀⠐⢣⠀⠀⡝⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⢠⠃⠀⠀⠀⠀⠀⢸⢡⠀⢃⠀⡇⣿⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⣿⠀⢸⠘⡠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⠀⠀⡾⠀⠀⠀⠀⠀⠀⡎⠀⢣⠀⢇⡁⢹⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⢀⡏⢠⠔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡎⠀⠀⣸⠃⠀⢀⠀⠀⠀⢠⠁⠁⠂⢃⢈⠇⢸⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⣸⠇⠈⡗⠒⠒⠒⢺⡇⠀⠀⠀⠀⠀⡇⠀⢠⡞⠀⢀⢜⠇⠀⣠⠃⠀⠀⢀⠎⠀⠀⠀⢠⠋⠀⣼⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⡟⠀⢰⠀⢣⠀⠀⢸⠇⠀⠀⠀⠀⠀⢣⠰⠟⢀⠰⠫⣃⡠⢊⠇⠀⠀⡠⢋⠀⠀⠀⠀⠸⠀⢠⡏⠀⠀⠀⠠⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⣸⠇⠀⠸⠀⠀⣧⡀⢀⣾⡀⠀⠀⢧⠀⠸⣀⡭⢥⣒⣒⣦⡄⠇⠤⠔⠊⠀⣴⣒⣒⡢⢤⠃⡠⣾⠁⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢠⠏⠀⠀⡇⠀⠀⡏⠻⣮⠈⢇⠀⠀⠈⢷⠄⣹⠉⠁⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠈⠧⡞⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⣠⠏⠀⠀⠀⡇⠀⢠⠇⠀⠈⠣⣌⣦⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⣧⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⢰⠏⠀⠀⠀⠀⢡⠀⡾⠀⠀⠀⠀⠀⠉⠷⣄⠀⠘⢶⠤⣄⣀⠀⢀⠔⡖⠉⠉⠉⠉⠓⣄⡤⠒⣪⠟⢇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⣾⠀⠀⠀⠀⠀⠘⣶⠁⠀⠀⠀⠀⡟⡉⠉⠉⠑⢢⣤⡻⠉⠛⣽⢟⠘⠀⠀⠀⠀⠀⠀⢸⡥⣚⣁⡀⠈⢦⣀⣀⣀⣀⡀⠀⠀⠀⠀
// ⠀⠀⢹⣷⡀⠀⠀⠀⣄⠸⡄⠀⠀⠀⠀⣷⢃⢸⠉⢿⣿⣈⣙⢢⣴⡗⠊⣉⡷⣄⠀⢒⠴⣊⡉⣭⡏⠁⠐⠒⠂⡤⠤⠤⠤⠭⠭⠁⠀⠀
// ⠀⠀⠀⠙⢿⣦⢄⠀⠘⣦⠘⣆⠀⠀⠀⢸⣸⡀⡗⣍⣍⢙⣿⣿⡏⢧⣠⣶⡇⠀⠉⠒⠉⠀⣿⣏⡇⠂⠄⠀⠀⠇⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠉⠳⢮⡀⠉⠆⠸⣆⠺⠍⣉⠉⠉⠀⠉⠑⠒⠯⠁⢰⣀⣭⡻⢴⣀⣀⣀⣠⣾⠥⢴⠃⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠸⠀⢸⣄⠀⠀⠈⢲⠀⠤⠀⠀⠒⠒⠒⢹⣓⠉⠉⠉⠉⠉⠉⠛⠍⣑⠂⠄⡀⠀⠘⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⣠⣤⡤⠔⠃⠀⢠⠀⣸⠛⠵⣦⢄⠈⠆⠀⠀⠀⠀⠀⠀⢧⠈⠢⢀⠀⠀⠀⣀⡀⠀⠀⠉⠐⠀⠇⠂⠰⣶⣰⣀⡀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠘⠦⣄⣀⣀⣤⠯⠜⠁⢷⠠⣄⣑⣛⠖⠶⠶⠒⠂⠉⠉⠁⠀⠀⠀⠉⠉⠒⠒⠒⠒⠂⠉⠉⠉⠉⠉⣀⣀⣀⢀⣀⠀⠀⠀

// SMAIL PRO IS LEGACY ATM

// TODO:
// SQ CONFIG
// IMAP

const axios = require('axios');
//const Promise = require('bluebird');
const EventEmitter = require('events');
const crypto = require('crypto');
const qs = require('qs');
const { existsSync, readFileSync, writeFileSync, readdirSync, statSync } = require('fs');
const path = require('path');
const socket = require('socket.io-client'); // socket.io-client@2.0.3
const { Semaphore, Mutex, tryAcquire } = require('async-mutex');
const { HttpProxyAgent, HttpsProxyAgent } = require('hpagent');
const { SocksProxyAgent } = require('socks-proxy-agent');
const retry = require('retry');
const assert = require('assert');
const ffmpeg = require('fluent-ffmpeg');
const LinkedList = require('dbly-linked-list');
const chalk = require('chalk');

const log = (message, color) => { // loggers
	console.log(chalk[color](message));
};

const logId = (id, message, color) => {
	console.log(chalk[color](chalk.dim(`[${id}]`) + ' - ' + message));
};


function asyncRetry(fn, opts) { // vercel/async-retry
	function run(resolve, reject) {
		var options = opts || {};
		var op;
	
		if (!('randomize' in options)) {
		  options.randomize = true;
		}
	
		op = retry.operation(options);
	
		function bail(err) {
		  reject(err || new Error('Aborted'));
		}
	
		function onError(err, num) {
		  if (err.bail) {
			bail(err);
			return;
		  }
	
		  if (!op.retry(err)) {
			reject(op.mainError());
		  } else if (options.onRetry) {
			options.onRetry(err, num);
		  }
		}
	
		function runAttempt(num) {
			var val;

			try {
				val = fn(bail, num);
			} catch (err) {
				onError(err, num);
				return;
			}

			Promise.resolve(val).then(resolve).catch(function catchIt(err) {
				onError(err, num);
			});
		}
	
		op.attempt(runAttempt);
	}

	return new Promise(run);
}

// use static binaries?
{
	const pathToFfmpeg = require('ffmpeg-static');
	ffmpeg.setFfmpegPath(pathToFfmpeg);
}


const between = (min, max) => {
	return Math.floor(Math.random() * (max - min + 1) + min)
}

const isUrl = (string) => { // shit code warning
	try {
		const url = typeof string === 'string' ? new URL(string) : string;
		return url.protocol === 'https:' || url.protocol === 'http:' || url.protocol === 'socks5:';
	}
	catch (_) {
		return false;
	}
}

const parseProxyString = (string, protocol) => { // shit code warning
	if (!isUrl(string)) {
		const credentials = string.split(':');
		const [ username, password, hostname, port ] = credentials; // format

		return {
			hostname: hostname.trim(),
			port: port.trim(),
			username: username.trim(),
			password: password.trim(),
			protocol: protocol + ':' // (:8085, socks5://)
		};
	}

	const url = new URL(string);

	const result = {
		hostname: url.hostname,
		port: parseInt(url.port, 10)
	};

	if (url.protocol.startsWith('http')) {
		result.protocol = `${result.protocol}:`;
	}

	if (url.username && url.password) {
		result.username = url.username;
		result.password = url.password;
	}

	return result;
}

class FxpHttpsProxyAgent extends HttpsProxyAgent {
	constructor(options) {
		// const defaultOptions = {
		// 	keepAlive: true,
		// 	keepAliveMsecs: 1000
		// };

		// Object.assign(options, defaultOptions);

		super(options);

		this.id = between(1000000, 9999999);
		this.fails = 0;
		this.last = new Date();
	}

	static fromStr(str) {
		const proxy = parseProxyString(str, 'http');
		
		return new FxpHttpsProxyAgent({ proxy });
	}
};

class FxpSocksProxyAgent extends SocksProxyAgent {
	constructor(options) {
		// const defaultOptions = {
		// 	keepAlive: true,
		// 	keepAliveMsecs: 1000
		// };

		// Object.assign(options, defaultOptions);

		super(options);

		this.id = between(1000000, 9999999);
		this.fails = 0;
		this.last = new Date();
	}

	static fromStr(str) {
		const proxy = parseProxyString(str, 'socks5');
		
		return new FxpSocksProxyAgent(proxy);
	}
};

// I KNOW U GON  LIE 2 MEEEE LIE 2 MEEE LIE 2 MEEE
// TRY TO TAKE WUTS MINE FROM MEEEEE

class BasicCookieJar { // alternative axios-cookiejar-support for custom proxies
	constructor(instance) {
		this.instance = instance;
		this.cookies = { };

		this.instance.interceptors.request.use((request) => { // append
			this.appendCookie(request);
			return request;
		});

		this.instance.interceptors.response.use((response) => { // store
			this.readCookie(response);
			return response;
		});
	}

	// I SWAER IT'S SO PURE FEELING NEWBORN
	processCookieHeader(header) {
		const [ part ] = header.split(';');
		const [ name, value ] = part.split('=');

		if (typeof name === 'string' && typeof value === 'string' && name.length > 0) {
			this.cookies[decodeURIComponent(name)] = decodeURIComponent(value);
		}
	}

	// XANS IN MY BACKPACK BRING EM TO YOUR DOOR
	readCookie(response) {
		const setCookie = response.headers['set-cookie'];

		if (Array.isArray(setCookie)) {
			// unusual
			setCookie.forEach((header) => {
				this.processCookieHeader(header);
			});
		}
		else if (typeof setCookie === 'string') {
			this.processCookieHeader(setCookie);
		}
	}

	toString() {
		let string = '';

		for (const name in this.cookies) {
			string += `${encodeURIComponent(name)}=${encodeURIComponent(this.cookies[name])};`;
		}

		return string;
	}

	appendCookie(request) {
		if (request.headers['cookie']) {
			request.headers['Cookie'] = request.headers['cookie'];
			delete request.headers['cookie'];
		}

		if (typeof request.headers['Cookie'] === 'string') { // already set?
			request.headers['Cookie'] += ';' + this.toString();
		}
		else {
			request.headers['Cookie'] = this.toString();
		}
	}
};

const necromancerNamespace = 'necromancerNamespace'; // for request config
const proxyOptions = Object.freeze({
	files: [ 'proxies.txt' ],
	interval: 50,
	threads: 10,
	retryDbErrors: true
});

const fixConfig = (axios, config) => { // credits axios-retry code
	if (axios.defaults.agent === config.agent) {
		delete config.agent;
	}
	if (axios.defaults.httpAgent === config.httpAgent) {
		delete config.httpAgent;
	}
	if (axios.defaults.httpsAgent === config.httpsAgent) {
		delete config.httpsAgent;
	}
}

class AgentPool { // object pool for proxy agent
	constructor() {
		this.avail = { };
		this.working = { };
		this.disabled = { };

		this.active = false;
		this.total = 0;
	}

	// RIDING IN MY CAR I MIGHT TRANSFORM
	push(proxy) {
		this.avail[proxy.id] = proxy;

		this.active = true;
		++this.total;
	}

	extend(proxies) {
		Object.assign(this.avail, ...proxies.map((agent) => {
			return { [agent.id]: agent };
		}));

		this.active = true;
		this.total += proxies.length;
	}

 	// WHY DID YOU LIE TO ME I WANNA KNOW FOR SURE
	clear() {
		this.avail = { };
		this.working = { };
		this.disabled = { };

		this.active = false;
		this.total = 0;
	}

	acquire() {
		if (this.active) {
			let agent;
			const deadProxies = Object.values(this.disabled)
				.filter((x) => x && x.last.getTime() - new Date().getTime() > 2 * 60 * 60 * 1000)
				.sort((a, b) => a.fails - b.fails);

			if (deadProxies.length) { // useless atm
				agent = deadProxies.pop();
				if (agent) {
					delete this.disabled[agent];
				}
			}

			if (!agent) {
				const avails = Object.keys(this.avail);
				const key = avails[between(0, avails.length - 1)];

				agent = this.avail[key];
				if (agent) {
					delete this.avail[key];
				}
			}

			if (!agent) {
				log(`failed switch!`, 'red');
			}
			else {
				this.working[agent.id] = agent;
			}

			return agent;
		}

		return { };
	}

	release(agent) {
		if (!(this.active && agent.id)) return;

		const old = this.working[agent.id];

		this.avail[agent.id] = old;

		delete this.working[agent.id];
	}

	disable(agent) {
		if (!agent.id) return;

		const old = this.avail[agent.id] ?? this.working[agent.id];

		delete this.avail[agent.id];
		delete this.working[agent.id];

		++old.fails;
		old.last = new Date();
		this.disabled[agent.id] = old;
	}

	isAvail(agent) {
		return this.avail[agent.id] != null;
	}

	isWorking(agent) {
		return this.working[agent.id] != null;
	}

	isDisabled(agent) {
		return this.disabled[agent.id] != null;
	}

	hasFree() {
		return Object.keys(this.avail).length > 0;
	}

	length() {
		return this.total;
	}
};

class AgentPoolSingleton { // for BaseClient's
	constructor() {
		if (!AgentPoolSingleton.instance) {
			log('loading and configuring proxies...', 'blue');

			const pool = new AgentPool();

			const proxies = proxyOptions.files.filter((path) => existsSync(path))
				.map((file) => readFileSync(file, 'utf-8').split('\n').filter(x => x))
				.flat()
				.map((str) => FxpSocksProxyAgent.fromStr(str));

			pool.extend(proxies);

			AgentPoolSingleton.instance = pool;

			log('loaded', 'blue');
		}
	}

	getInstance() {
		return AgentPoolSingleton.instance;
	}
};

class BaseClient {
	configureInstance() {
		this._instance = axios.create({
			...this.config.setup,

			transformRequest: axios.defaults.transformRequest,
			transformResponse: axios.defaults.transformResponse
		});

		if (this.config.useJar) {
			this.jar = new BasicCookieJar(this.instance);
		}

		const requestInterceptor = this._instance.interceptors.request.use(this.requestAdapter.bind(this));
		const responseInterceptor = this._instance.interceptors.response.use(this.responseAdapter.bind(this), this.errorAdapter.bind(this));
		
		this.interceptors = { requestInterceptor, responseInterceptor };
	}

	get instance() {
		if (!this._instance) {
			this.configureInstance();
		}

		return this._instance;
	}

	loadFiles(options) {
		const singleton = new AgentPoolSingleton();
		this.pool = singleton.getInstance();

		// update
		const availProxy = Object.keys(this.pool.avail).length - 1;
		if (options.threads < availProxy) {
			options.threads = availProxy;
		}

		Object.assign(this.config, options);
	}

	constructor(config) {
		this.activeSessions = 0;
		this.requests = 0;

		this.config = config;

		this.loadFiles(this.config); // load proxy files
	}

	requestAdapter(request) {
		return new Promise((resolve, reject) => {
			const interval = setInterval(() => {
				const canUse = (this.activeSessions < this.config.threads && (!this.pool.active || this.pool.hasFree()));
				if (!canUse) {
					return;
				}

				++this.activeSessions;

				const {
					useProxy = true,
					disposable = false,
					retry = true
				} = { ...request[necromancerNamespace] };

				fixConfig(this.instance, request); //  https://github.com/mzabriskie/axios/issues/370

				if (useProxy === false) {
					clearInterval(interval);
					++this.request;
					resolve(request);
					return;
				}

				if (disposable || this.agent == null || !this.pool.isWorking(this.agent)) {
					this.agent = this.pool.acquire();
					log(`renew agent! ${this.agent.id}`, 'blue');
				}
				
				if (this.pool.active && !this.agent) {
					return;
				}

				clearInterval(interval);
				if (this.agent) {
					request.httpAgent = this.agent;
					request.httpsAgent = this.agent;
				}
				else if (this.pool.active) {
					log('expected proxy!', 'red');
				}

				++this.requests;
				resolve(request);
			}, this.config.interval);
		})
	}

	responseAdapter(response) {
		const {
			useProxy = true,
			disposable = false,
			retry = true
		} = { ...response.config[necromancerNamespace] };

		this.activeSessions = Math.max(0, this.activeSessions - 1);

		if (disposable) {
			this.pool.release(response.config.httpsAgent);
		}

		if (!retry) {
			return Promise.resolve(response);
		}

		const path = response.request.path;
		const body = response.data;

		const disableProxy = () => {
			this.pool.disable(response.config.httpsAgent);
			this.config.threads--;

			if (!this.pool.hasFree()) {
				return Promise.reject(response);
			}
		}

		const result = this.responseCheck(response);

		if (result && response.config.httpsAgent != null) {
			//log('responseCheck passed', 'blue');
			log(`responseCheck ${path}`, 'magenta');
			if (result !== 'noDisable') {
				log(`dissable ${path}`, 'magenta');
				disableProxy();
			}

			return this.instance(response.config);
		}

		return Promise.resolve(response);
	}

	errorAdapter(error) {
		const {
			useProxy = true,
			disposable = false,
			retry = true
		} = { ...error.config[necromancerNamespace] };

		const path = error.request.path;

		this.activeSessions = Math.max(0, this.activeSessions - 1);

		if (disposable) {
			this.pool.release(error.config.httpsAgent);
		}

		if (!retry) {
			return Promise.reject(error);
		}

		if (!error.response) {
			log(`bad response? ${path}`, 'magenta');
			return this.instance(error.config);  //reject(error);
		}
		
		const disableProxy = () => {
			this.pool.disable(error.config.httpsAgent);
			this.config.threads--;

			if (!this.pool.hasFree()) {
				return Promise.reject(error);
			}
		}

		const result = this.errorCheck(error);

		if (result && error.config.httpsAgent != null) {
			if (result === 'ignore') {
				log(`ignore ${path}`, 'magenta');
				return;
			}
			else if (result !== 'noDisable') { // lazy
				log(`disable ${path}`, 'magenta');
				disableProxy();
			}

			log(`result ${path}`, 'magenta');
			return this.instance(error.config);
		}
		else { // 50x possible to retry
			const isProxyError = [ 501, 503 ].includes(error.response.status);
			if (isProxyError) {
				disableProxy();
				log(`isProxyError ${path}`, 'magenta');
				return this.instance(error.config);
			}
			else {
				// TODO: move this to beginning?
				const isServerError = error.message.includes('ECONNRESET')
					|| error.message.includes('ECONNREFUSED')
					|| [ 502, 504 ].includes(error.response.status);

				if (isServerError) {
					log(`isServerError ${path}`, 'magenta');
					return this.instance(error.config);
				}
				else {
					return Promise.reject(error);
				}
			}
		}
	}

	errorCheck(error) {
		throw new Error('errorCheck unimplemented');
	}

	responseCheck(response) {
		throw new Error('responseCheck unimplemented');
	}
};

const FXP_BASE_URL = 'https://www.fxp.co.il';

class FxpClient extends BaseClient {
	constructor(config) {
		super({
			setup: {
				baseURL: FXP_BASE_URL,
				timeout: 15000,
				withCredentials: true,
				maxRedirects: 0,
				headers: {
					'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36'
				}
			},
			useJar: true,
			...config
		});
	}

	responseCheck(response) {
		const path = response.request.path;
		const body = response.data;

		if (body != null && typeof body === 'string' && body === 'Rate Limited') {
			//console.log('rate limited on:', path);
			return true;
		}

		if (body != null && typeof body === 'string' && body.includes('standard_error') && body.includes('/cdn-cgi/l/email-protection#') && body.includes('אייפי')) { // changeEmail proxy ban
			//console.log('yupProxy', path);
			return 'forced';
		}

		if (path.startsWith('/newthread.php') || path.startsWith('/newreply.php')) {
			if (body.includes(`חלה תקלה בפרסום ההודעה`)) {
				return true;
			}
		}

		return false;
	}

	errorCheck(error) {
		// lazy, some stuff handled at baseClient
		const path = error.request.path;
		const status = error.response?.status;

		if (status === 303) { // redirects..
			return 'ignore';
		}

		if (status != null && status >= 502 && path.startsWith('/register.php')) {
			return 'noDisable'; // lazy
		}

		return false; // default checks for it
	}
};


const EMAILNATOR_BASE_URL = 'https://www.emailnator.com';

class GmailnatorClient extends BaseClient {
	constructor(config) {
		super({
			setup: {
				baseURL: EMAILNATOR_BASE_URL,
				withCredentials: true,
				timeout: 7000
			},
			useJar: true,
			...config
		});
	}

	// have to be handled by user.
	responseCheck(response) {
		return false;
	}

	errorCheck(error) {
		if (error.response.status === 400 || error.response.status === 429) {
			return true;
		}

		return false;
	}
};


const SMAILPRO_BASE_URL = 'https://smailpro.com';

class SmailProClient extends BaseClient {
	constructor(config) {
		super({
			setup: {
				baseURL: SMAILPRO_BASE_URL,
				withCredentials: true,
				timeout: 7000
			},
			useJar: true,
			...config
		});
	}

	responseCheck(response) {
		// data.code: 410 - data.msg: 'This email address is not activated yet' - data.items: []
		if (response.data && typeof response.data.code === 'number') {
			if (response.data.code === 410) {
				return true;
			}

			return response.data.code !== 200;
		}

		return false;
	}

	errorCheck(error) {
		return error.response != null; // idk?
	}
};

class MessageWatcher {
	async getNewMsgs(options) {
		const mutex = this.client.getIdxMutexs(options.emailIdx).messages;
		await mutex.waitForUnlock();

		await this.refreshCache(options);

		const result = [ ];
		this.cached.forEach((message) => {
			if (!this.lookup[message.messageID]) {
				result.push(message);
			}
		});

		// mark
		this.cached.forEach((message) => { this.lookup[message.messageID] = true; });

		return result;
	}

	async waitForNewMsgs(options) {
		return asyncRetry(async (bail, currentTry) => {
			const newMsgs = await this.getNewMsgs(options).then((messages) => {
				return messages.filter((message) => message.from.includes(options?.from ?? ''));
			});

			if (newMsgs.length < (options?.minLength ?? 1)) {
				throw new Error('empty messages');
			}

			return newMsgs;
		}, {
			retries: (options?.maxAttempts ?? 5)
		});
	}

	getIdxMutexs(idx) {
		throw new Error('MessageWatcher.getIdxMutexs unimplemented');
	}

	async refreshCache(options) {
		throw new Error('MessageWatcher.refreshCache unimplemented');
	}
}

class GmailnatorMessages extends MessageWatcher {
	constructor(client) {
		super(client);

		this.client = client;
		this.cached = [ ];
		this.lookup = { };
	}

	async refreshCache(options) {
		//console.log('refreshCache:', options);
		const mutexs = this.client.getIdxMutexs(options.emailIdx);

		try {
			return await tryAcquire(mutexs.messages).runExclusive(async () => {
				const messageList = await this.client.post('message-list', {
					email: this.client.emails[options.emailIdx]
				}, {
					useProxy: false,
					//disposable: true,
					//retry: false
				});

				return this.cached = messageList.messageData.map((item) => {
					return {
						...item,
						emailIdx: options.emailIdx
					};
				});
			});
		}
		catch (err) {
			if (err.message === 'mutex already locked') {
				return;
			}
			else if (err.response.status === 500) {
				// TODO?
			}

			console.log('refreshCache', err);
			throw err;
		}
	}

	async readMsg(options) {
		return this.client.post('message-list', { 
			email: this.client.emails[options.emailIdx],
			messageID: options.messageID
		}, {
			useProxy: false
		});
	}
};

class BaseRefresher {
	static queue = { };

	static async testAction(client, idx) {
		throw new Error('BaseRefresher.action unimplemented');
	}

	static async refreshEmail(client, idx, depth = 0) {
		const result = await this.testAction(client, idx);
		if (result) {
			return depth;
		}

		await client.generate(idx);
		await client.refreshEmail(idx); // ??
	}
};

class GmailnatorRefresher extends BaseRefresher {
	static async testAction(client, idx) {
		try {
			await client.post('message-list', {
				email: client.emails[idx]
			}, {
				useProxy: false,
				retry: false
			});

			return true;
		}
		catch (err) {
			return false;
		}
	}
};

class Gmailnator {
	constructor() {
		const client = new GmailnatorClient({
			...proxyOptions,
			threads: 15
		});

		this.client = client;
		this.agent = client.instance;

		this.emails = [ ];

		this.mutexs = { };
		this.fxpFrom = 'support@fxp.co.il';
	}
	
	refreshEmail(idx, depth = 0) {
		return GmailnatorRefresher.refreshEmail(this, idx, depth);
	}

	async post(endpoint, data, necromancerData) {
		return this.agent.post(endpoint, data, {
			headers: this.getHeaders(),
			[necromancerNamespace]: necromancerData
		}).then((response) => response.data);
	}

	getIdxMutexs(idx) {
		if (!this.mutexs[idx]) {
			this.mutexs[idx] = {
				messages: new Mutex(),
				refresh: new Mutex()
			};
		}

		return this.mutexs[idx];
	}

	async init(amount) {
		await this.resolveXsrf();

		this.messages = new GmailnatorMessages(this);

		await this.generateAll(amount);
	}

	getHeaders() {
		return {
			'Content-Type': 'application/json',
			'x-xsrf-token': this.xsrfToken
		}
	}

	async resolveXsrf() {
		const xsrfToken = await new Promise((resolve, reject) => {
			this.agent.get('/').then(() => {
				const xsrfToken = decodeURIComponent(this.client.jar.cookies['XSRF-TOKEN']);
				resolve(xsrfToken);
			});
		});

		this.xsrfToken = xsrfToken;
	}

	async generate(idx) {
		const refreshMutex = this.getIdxMutexs(idx).refresh;
		if (refreshMutex.isLocked()) {
			return;
		}

		const release = await refreshMutex.acquire();
		//console.log('refreshMutex acquire-d', idx);
		try {
			const [ email ] = await this.post('generate-email', {
				email: [ 'dotGmail' ],
				emailNo: '1'
			}, {
				useProxy: false,
				retry: false
			}).then((data) => data.email);

			//console.log('setGenerate', idx, email);
			this.emails[idx] = email;

			release();
		}
		catch (e) {
			//console.log('generateerror:', e);
		}
		finally {
			//console.log('generated for:', idx);
			release();
		}
	}

	async safeGenerate(idx) {
		await this.generate(idx);
		await this.refreshEmail(idx);
	}

	async generateAll(amount) {
		log(`generating ${amount} emails..`, 'blue');
		for (let i = 0; i < amount; ++i) {
			log(`generating ${i+1}/${amount}..`, 'blue');
			await this.safeGenerate(i);
		}
		log(`finished generation emails..`, 'blue');
	}
};


class SmailProRefresher extends BaseRefresher {
	static async testAction(client, poll, idx) {
		try {
			const result = await client.messages.getMsgs(poll[idx]);

			return (result.data.code === 200);
		}
		catch (_) {
			return false;
		}
	}
};

class SmailPro { // DO NOT USE THIS. GHAVE TO BE UPDATED
	constructor() {
		const client = new SmailProClient({
			...proxyOptions,
			threads: 5
		});

		this.client = client;
		this.agent = client.instance;

		this.fxpFrom = 'FXP'; // lazy
	}

	refreshEmail(emails, idx, depth = 0) {
		return SmailProRefresher.refreshEmail(this, emails, idx, depth);
	}

	async init(amount) {
		this.appId = await this.getAppId();

		const [ rapidEndpoint, rapidKey ]  = await this.grabRapidData();
		this.rapidEndpoint = rapidEndpoint;
		this.rapidKey = rapidKey;

		this.messages = new SmailProMessages(this);

		this.emails = [ ];

		await this.generate(amount, true);
	}

	async grabSmailKey(data) {
		const info = data ?? { domain: 'gmail.com', server: 'server-1', type: 'alias', username: 'random' };

		const result = await this.agent.post('./app/key', {
			...info,
			[necromancerNamespace]: {
				useProxy: false
			}
		});

		// handle .code not 200 & response statuscode at client

		return result.data.items;
	}

	async getAppVersion() {
		const advancedDom = await this.agent.get('advanced', {
			[necromancerNamespace]: {
				useProxy: false
			}
		});

		return /\/js\/app\.js\?v=([^"]+)/.exec(advancedDom.data)[1];
	}
	
	async getAppId() {
		const appVersion = await this.getAppVersion();
		const appScript = await this.agent.get('./js/app.js', {
			params: { v: appVersion },
			[necromancerNamespace]: {
				useProxy: false
			}
		});

		const [ , entryId, entryValue ] = /(\d+):"smailpro_v2_email".*?\1:"(\w+)"/.exec(appScript.data);

		return entryValue;
	}

	async grabRapidData() {
		const response = await this.agent.get('./js/chunks/smailpro_v2_email.js', {
			params: { id: this.appId },
			[necromancerNamespace]: {
				useProxy: false
			}
		});

		const [ , rapidEndpoint, rapidKey ] = /rapidapi_endpoint:"(https?:\/\/(?:[\w-]+\.?)+[^"])+?",rapidapi_key:"(\w+)"/.exec(response.data);

		return [ rapidEndpoint, rapidKey ];
	}

	async generate(amount, doSet) {
		const key = await this.grabSmailKey(); // check if its better to keep it?
		const emails = [ ];

		// must test before re-generate
		for (let i = 0; i < amount; ++i) {
			const result = await this.agent.get(`${this.rapidEndpoint}/email/gm/get`, {
				params: {
					key,
					'rapidapi-key': this.rapidKey,
					domain: 'gmail.com',
					username: 'random',
					server: 'server-1',
					type: 'alias'
				},
				[necromancerNamespace]: {
					useProxy: true,
					disposable: true
				}
			});

			const email = result.data.items;
			email.toString = () => {
				return email.email;
			}

			emails[i] = email;
			
			let depth = await this.refreshEmail(emails, i);

			console.log('yea', i, depth);
		}

		// handle .code not 200 & response statuscode at client
		if (doSet) {
			this.emails = this.emails.concat(emails);
		}

		return emails;
	}
};


class SmailProMessages extends MessageWatcher {
	constructor(client) {
		super(client);

		this.client = client;
		this.cached = [ ];
	}

	async readMsg(options) {
		const key = await this.client.grabSmailKey({ email: options.email, message_id: options.messageID });

		const result = await this.client.agent.get(`${this.client.rapidEndpoint}/email/gm/read`, {
			params: {
				key,
				'rapidapi-key': this.client.rapidKey,
				email: options.email,
				message_id: options.messageID
			},
			[necromancerNamespace]: {
				useProxy: false
			}
		});

		return result.data.items.body;
	}

	async getMsgs(options) {
		const key = await this.client.grabSmailKey({
			email: options.email,
			timestamp: options.timestamp
		});

		return this.client.agent.get(`${this.client.rapidEndpoint}/email/gm/check`, {
			params: {
				key,
				'rapidapi-key': this.client.rapidKey,
				email: options.email,
				timestamp: options.timestamp
			},
			[necromancerNamespace]: {
				useProxy: true,
				disposable: true
			}
		});
	}

	async refreshCache(options) {
		const msgs = await this.getMsgs(options.email);
		if (msgs.data.code === 410) {
			throw new Error('uh oh');
		}

		return this.cached = msgs.data.items.map((item) => {
			return {
				//...item,
				messageID: item.mid,
				email: item.textTo.trim(),
				from: item.textFrom.trim()
			};
		});
	}
};

class ImapClient { };

class FxpApiWrapper {
	constructor(agent) {
		this.agent = agent; // must baseURL
	}

	loginUser(account) {
		const data = qs.stringify({
			do: 'login',
			vb_login_username: account.username,
			password: '',
			s: '',
			to_homepage: 1,
			securitytoken: 'guest',
			vb_login_md5password: account.passwordHash,
			vb_login_md5password_utf: account.passwordHash,
			cookieuser: 1
		});

		return this.agent.post('login.php?do=login', data, {
			[necromancerNamespace]: {
				//useProxy: true
			}
		});
	}

	createUser(account, email) {
		const data = qs.stringify({
			do: 'addmember',
			username: account.username,
			password: '',
			passwordconfirm: '',
			email: email,
			emailconfirm: '',
			agree: 1,
			s: '',
			securitytoken: 'guest',
			url: FXP_BASE_URL,
			password_md5: account.passwordHash,
			passwordconfirm_md5: account.passwordHash,
			day: '',
			month: '',
			year: ''
		});

		return this.agent.post('register.php?do=addmember', data, {
			[necromancerNamespace]: {
				useProxy: true,
				disposable: true
			}
		});
	}

	changeEmail(account, newEmail) {
		newEmail = newEmail ?? Math.random().toString(21) + '@gmail.com'; // empty means a random email

		const data = qs.stringify({
			do: 'updatepassword',
			email: newEmail,
			emailconfirm: newEmail,
			s: '',
			newpassword: '',
			newpasswordconfirm: '',
			currentpassword: '',
			newpassword_md5: '',
			newpasswordconfirm_md5: '',
			securitytoken: account.securityToken,
			currentpassword_md5: account.passwordHash 
		});

		return this.agent.post('profile.php?do=updatepassword', data, {
			[necromancerNamespace]: {
				useProxy: true,
				//disposable: true
			}
		});
	}

	replyThread(account, tid, message) {
		message = message.replace(/\n/g, '<br>');

		const data = qs.stringify({
            ajax: 1,
			securitytoken: account.securityToken,
			ajax_lastpost: 1234,
			message_backup: message,
			message: message,
			wysiwyg: 1,
			s: '',
			fromquickreply: 1,
			do: 'postreply',
			p: 'who cares',
			specifiedpost: 0,
			parseurl: 1,
			loggedinuser: account.uid,
			posthash: '9271d6eecedd55fcfa6143a33029d496',
			poststarttime: 12341234,
        });

        return this.agent.post(`newreply.php?do=postreply&t=${tid}`, data, {
			[necromancerNamespace]: {
				useProxy: true,
				//disposable: true
			}
		});
	}

	deletePost(account, pid) {
		const data = qs.stringify({
			s: '',
			securitytoken: account.securityToken,
			p: pid,
			url: FXP_BASE_URL + `/showthread.php?p=${pid}`,
			do: 'deletepost'
		});

		return this.agent.post(`editpost.php?do=deletepost&p=${pid}`, data);
	}

	createThread(account, fid, title, content, prefix = 'dis') {
		content = content.replace(/\n/g, '<br>');
		title = title.substring(0, 75);

		const data = qs.stringify({
            prefixid: prefix,
			subject: title,
			message_backup: content,
			message: content,
			wysiwyg: 1,
			s: '',
			securitytoken: account.securityToken,
			f: fid,
			do: 'postthread',
			posthash: '',
			poststarttime: '',
			loggedinuser: account.uid,
			sbutton: 'צור אשכול חדש',
			signature: 0,
			parseurl: 1
        });

		// TODO
		return this.agent.post(`newthread.php?do=postthread&f=${fid}`, data, {
			[necromancerNamespace]: {
				useProxy: true,
				//disposable: true
			}
		});
	}

	editMessage(account, pid, newContent) {
		const data = qs.stringify({
			securitytoken: account.securityToken,
            do: 'updatepost',
            ajax: '1',
            postid: pid,
            poststarttime: '1593697060',
            message: newContent,
            reason: '',
            relpath: `showthread.php?p=${pid}`
		});

		return this.agent.post(`editpost.php?do=updatepost&postid=${pid}`, data);
	}

	addLike(account, pid) {
		const data = qs.stringify({
			do: 'add_like',
			postid: pid,
			fxppro: '',
			securitytoken: account.securityToken
		});

		return this.agent.post('ajax.php', data, {
			[necromancerNamespace]: {
				useProxy: false,
				retry: false
			}
		});
	}

	newPm(account, recipient, subject, message) {
		//message = message.replace(/\n/g, '<br>');

		const data = qs.stringify({
			securitytoken: account.securityToken,
			do: 'insertpm',
            recipients: recipient,
            title: subject,
            message: message,
            savecopy: '1',
            signature: '1',
            parseurl: '1',
            frompage: '1'
		});

		return this.agent.post('private_chat.php', data); // TODO: use pmId.
	}

	replyPm(account, pmId, recipient, message) {
		//message = message.replace(/\n/g, '<br>');

		const data = qs.stringify({
			message: message,
            fromquickreply: '1',
            securitytoken: account.securityToken,
            do: 'insertpm',
            pmid: pmId,
            loggedinuser: account.uid,
            parseurl: '1',
            signature: '1',
            title: 'תגובה להודעה:',
            recipients: recipient,
            forward: '0',
            savecopy: '1',
            fastchatpm: '1',
            wysiwyg: '1',
		});

		return this.agent.post('private_chat.php', data);
	}

	changeSignature(account, content) {
		const data = qs.stringify({
			do: 'updatesignature',
			url: FXP_BASE_URL + '/',
			s: '',
			securitytoken: account.securityToken,
			MAX_FILE_SIZE: 52428800,
			wysiwyg: 1,
			message: content,
			message_backup: ''
		});

		return this.agent.post('profile.php?do=updatesignature', data, {
			[necromancerNamespace]: {
				useProxy: false,
				retry: false
			}
		});
	}

	changeImage(account, imgUrl, del) {
		//imgUrl = imgUrl.replace('i.imagesup.co', 'profile.fcdn.co.il');

		const data = qs.stringify({
			do: 'update_profile_pic',
			profile_url: imgUrl,
			del, 
			user_id: account.uid,
			securitytoken: account.securityToken
		});

		return this.agent.post('private_chat.php', data, {
			[necromancerNamespace]: {
				//useProxy: true,
				//retry: false
			}
		});
	}

	getQuoted(account, pid) {
		const data = qs.stringify({
			p: pid,
			do: 'getquotes',
			securitytoken: account.securityToken
		});

		return this.agent.post('ajax.php?do=getquotes&p=' + pid, data).then((resp) => resp.data).then((data) => {
			const [ full, username, content ] = /\[QUOTE=([^;]+);\d+\](.*?)\[\/QUOTE\]/ms.exec(data);

			return { full, username, content };
		});
	}

	// custom

	replyComment(account, pid, message, quoted = true) {
		return (quoted ? this.getQuoted(account, pid) : Promise.resolve({ full: '' })).then(({ full }) => {
			message = (full + message).replace(/\n/g, '<br>');

			const data = qs.stringify({
	            ajax: '1',
				securitytoken: account.securityToken,
				ajax_lastpost: 1234,
				message_backup: message,
				message: message,
				s: '',
				fromquickreply: 1,
				do: 'postreply',
				p: 'who cares',
				specifiedpost: 0,
				parseurl: 1,
				loggedinuser: account.uid,
				posthash: '9271d6eecedd55fcfa6143a33029d496',
				poststarttime: 12341234,
	        });

	        return this.agent.post(`newreply.php?do=postreply&p=${pid}`, data);	
	    });
	}

	friendMessage(account, recipientId, message) {
		const data = qs.stringify({
			message: message,
			message_backup: message,
			wysiwyg: 1,
			fromquickcomment: 1,
			s: '',
			sbutton: 'פרסם הודעה',
			do: 'message',
			u: recipientId,
			u2: '',
			securitytoken: account.securityToken,
			parseurl: 1,
			lastcomment: '',
			allow_ajax_qc: '1',
			fromconverse: ''
		});

		return this.agent.post('visitormessage.php?do=message', data, {
			[necromancerNamespace]: {
				useProxy: true
			}
		});
	}
};

class Fxp extends EventEmitter {
	constructor(account) {
		super();
		this.setMaxListeners(Infinity);

		const client = new FxpClient({
			...proxyOptions
		});

		this.client = client;
		this.agent = client.instance;

		this.api = new FxpApiWrapper(this.agent);
		this.createMutex = new Mutex();

		const banManager = this.agent.interceptors.response.use(((response) => {
			if (!response) {
				return;
			}

			const data = response.data;

			if (this.created && typeof data === 'string' && data.includes('STOKEN = ""') && data.includes('standard_error')) {
				log(`hit a ban for ${this.account.id}`, 'blue');
				//this.agent.interceptors.response.eject(banManager);
				this.banned = true;
				this.emit('banned');
				return { data: 'banned' };
			}
			return response;
		}).bind(this));

		this.on('verify', () => {
			this.verified = true;
		});

		if (account.passwordHash == null && account.password != null && typeof account.password === 'string')
			account.passwordHash = crypto.createHash('md5').update(account.password).digest('hex');

		this.account = account; // = credentials

		this.created = false;
		this.verified = false;
		this.banned = false;
		this.swapped = new Mutex();
	}

	//get created() {
	//	return !!this.account.uid;
	//}

	onLogResponse(response) {
		const result = /(?:const|var)\s+SECURITYTOKEN\s+?=\s+?["'](\d+\-[0-9a-f]{39,64})["'];?/.exec(response.data);
		if (result) {
			this.account.securityToken = result[1];
			this.account.uid = /USER_ID_FXP\s+?=\s+?["'](\d+)["']/.exec(response.data)[1];
			log(`new account created! ${this.account.uid}`, 'yellow');
		} else {
			// side-note: server checks first email
			if (response.data.includes('login.php?do=lostpw')) {
				throw new Error('email already used');
			}
			else if (response.data.includes('mobile.php?do=login')) {
				throw new Error('username already used');
			}
			else if (response.data.includes(`לא השלמת את כל השדות שחובה להשלימם`)) {
				throw new Error('no email provided');
			} /*else if (response.status === 503) { // <---------- (?)
				throw new Error('database deadlock');
			} */

			console.log('UNKNOWNFAILED', response.data);

			throw new Error('unknown failed in creating/logging user!');
		}

		this.created = true;
	}

	async loginUser() {
		return this.createMutex.runExclusive(async () => {
			if (this.created) return true;

			await this.api.loginUser(this.account);

			const homeResponse = await this.agent.get('./', {
				[necromancerNamespace]: {
					useProxy: false
				}
			});
			this.onLogResponse(homeResponse);
			return true;
		});
	}

	async createUser(email) {
		return this.createMutex.runExclusive(async () => {
			if (this.created) return true;
			
			const response = await this.api.createUser(this.account, email);

			this.onLogResponse(response);

			return true;
		});
	}

	getQuoted(pid) {
		return this.api.getQuoted(this.account, pid);
	}

	async changeEmail(newEmail) {
		// shit code
		return await tryAcquire(this.swapped).runExclusive(async () => {
			const result = await this.api.changeEmail(this.account, newEmail);

			if (result == null) {
				return; // sucesss
			}

			const data = result.data;

			if (data == null || typeof data !== 'string') {
				throw new Error('email already used'); // dunno?
			}

			if (data.includes('login.php?do=lostpw')) {
				throw new Error('email already used');
			}

			return Promise.resolve(result);
		});
	}

	replyThread(tid, message) {
		return this.api.replyThread(this.account, tid, message);
	}

	deletePost(pid) {
		return this.api.deletePost(this.account, pid);
	}

	createThread(fid, title, content, prefix = 'dis') {
		return this.api.createThread(this.account, fid, title, content, prefix);
	}

	editMessage(pid, newContent) {
		return this.api.editMessage(this.account, pid, newContent);
	}

	addLike(pid) {
		return this.api.addLike(this.account, pid);
	}

	newPm(recipient, subject, message) {
		return this.api.newPm(this.account, recipient, subject, message);
	}

	replyPm(pmId, recipient, message) {
		return this.api.replyPm(this.account, pmId, recipient, message);
	}

	changeSignature(content) {
		return this.api.changeSignature(this.account, content);
	}

	changeImage(imgUrl, del) {
		return this.api.changeImage(this.account, imgUrl, del);
	}

	replyComment(pid, message, quoted = true) {
		return this.api.replyComment(pid, message, quoted);
	}

	friendMessage(recipientId, message) {
		return this.api.friendMessage(this.account, recipientId, message);
	}
};

class FxpImageUploader {
	constructor(client) {
		if (client == null) return;

		this.client = client;
		this.agent = client.agent;
	}

	async uploadCdnAsync(imgUrl) {
		let blob;
		if (isUrl(imgUrl)) {
			const response = await fetch(imgUrl);
			blob = await response.blob();
		}
		else {
			blob = new Blob([ readFileSync(imgUrl) ]);
		}

		const form = new FormData();
		form.append('fileToUpload', blob, `${crypto.randomBytes(8).toString('hex')}.jpg`);

		const result = await (this.agent ?? axios).post(FXP_BASE_URL + '/uploads/difup.php', form, {
			[necromancerNamespace]: {
				useProxy: true,
				disposable: true
			}
		});
		const normal = result.data.image_link;
		const profileImage = normal.replace('i.imagesup.co', 'profile.fcdn.co.il');

		return { normal, profileImage };
	}

	async uploadFromUrls(urls) {
		return Promise.all(urls.map(async (url) => await this.uploadCdnAsync(url)));
	}

	async uploadFromFiles(directory) {
		const names = readdirSync(directory);
		const paths = names.filter((name) => ['.jpg', '.jpeg', '.png', '.gif'].includes(name.substring(name.lastIndexOf('.'))))
			.map((name) => path.join(directory, name))

		// TODO: move to DoctorMcKay's AsyncQueue

		return Promise.all(paths.map(async (path) => await this.uploadCdnAsync(path)));
	}
}

class FxpVoiceUploader {
	static outputFile = './record.ogg';
	static audioBitRate = 128;
	static fileLimit = 30 * 1000000;

	static compressOpus(file) {
		return new Promise((resolve, reject) => {
			ffmpeg(file)
				.inputFPS(1)
				.noVideo()
				//.audioCodec('libopus')
				.audioBitrate(FxpVoiceUploader.audioBitRate)
				.format('webm') // MediaRecorder
				.output(FxpVoiceUploader.outputFile)
				.on('end', () => {
					const data = readFileSync(FxpVoiceUploader.outputFile).toString('base64');

					resolve(data);
				})
				.run();
		});
	}

	async pollUntilFinished(url) {
		return new Promise((resolve, reject) => {
			const operation = retry.operation({
				retries: 10,
				factor: 2,
				minTimeout: 2000,
				maxTimeout: 2000,
				randomize: false,
			});

			operation.attempt(async (currentTry) => {
				try {
					const response = await this.client.agent.head(url);
					resolve(response);
				}
				catch (err) {
					if (operation.retry(err)) return;
				}
			});
		});
	}

	async saveToDatabase(data) {
		const result = await this.client.agent.postForm('https://voice.fcdn.co.il/sound', {
			function: 'insertaudio',
		   	data: data.blob,
	    	p: 0, // SOX_PITCH_FORMAT
	    	id: data.record.en_id,
	    	vid: data.record.voice_id,
	    	vid2: data.record.en_int_id,
	    	u_id: this.client.account.uid,
	    	to: data.record.to,
	    	f_id: 0,
		});

		const url = `https://voice2.fcdn.co.il/sound2/${result.data.trim()}.mp3`;

		try {
			await this.pollUntilFinished(url);
			return url;
		}
		catch (e) {
			throw new Error('FxpVoiceUploader.pollUntilFinished failed!' + e);
		}
	}

	async postRecord(blob, duration = 0) {
		const result = await this.client.agent.postForm('ajax.php', {
			do: 'insert_voice_data',
        	thread_voice: 0,
        	duration,
        	sox: 0, // SOX_PITCH_FORMAT
        	f_id: 0,
        	securitytoken: this.client.account.securityToken
		});

		return this.saveToDatabase({ blob, record: result.data });
	}

	async recordFromFile(file) {
		const asBlobUri = (data) => `data:audio/ogg;codecs=opus;base64,${data}`;

		if (file == null) { // re-upload last record
			 const data = readFileSync(FxpVoiceUploader.outputFile).toString('base64');

			 return this.postRecord(asBlobUri(data));
		}

		const { size } = statSync(file);

		assert (size < FxpVoiceUploader.fileLimit, 'file over limit!');

		const data = await FxpVoiceUploader.compressOpus(file);

		return this.postRecord(asBlobUri(data));
	}

	constructor(dummyClient) {
		this.client = dummyClient;
	}
};

class AsyncClientQueue { // jasonsjones/queue-fifo
	constructor() {
		this.list = new LinkedList();
	}

	enqueue(item) {
		return this.list.insert(item);
	}

	size() {
		return this.list.getSize();
	}

	dequeue() {
		if (this.isEmpty()) {
			return;
		}

		return this.list.removeFirst().getData();
	}

	isEmpty() {
		return this.list.isEmpty();
	}

	front() {
		if (this.isEmpty()) {
			return;
		}

		return this.list.getHeadNode().getData();
	}

	static fromArray(elements) {
		const queue = new AsyncClientQueue();

		for (const element of elements) {
			queue.enqueue(element);
		}

		return queue;
	}
};

class WorkerStats {
	constructor() {
		this.attempts = 0;
		this.created = 0;
		this.verified = 0;
		this.finished = 0;
	}
}

// TODO: database?
class FxpWorker {
	getVerifyUrls(client) { // stranded in the kalahari, will you share your flask?
		return new Promise(async (resolve, reject) => {
	  		const minLength = 1;
	  		const verificationMessages = await this.emailClient.messages.waitForNewMsgs({
	  			emailIdx: this.workerId,
	  			from: this.emailClient.fxpFrom, // 'support@fxp.co.il'(Gmailnator) or 'FXP'(SmailPro)
	  			maxAttempts: 5,
	  			delayMs: 3000,
	  			minLength: minLength
	  		});

	  		const urls = [ ];
	  		verificationMessages.forEach(async (message) => {
	  			const body = await this.emailClient.messages.readMsg(message);
	  			const url = /<a href="(https:\/\/www\.fxp\.co\.il\/register\.php\?a=act&u=\d+&i=[a-fA-F0-9]+)"/.exec(body)?.[1];;

	  			//if (url && !url.includes(`&u=${client.account.uid}`)) {
	  				//console.log('fake', this.workerId);
	  			//}

	  			if (url && url.includes(`&u=${client.account.uid}`)) {
	  				//console.log('real', this.workerId);
	  				urls.push(url);
	  			}

	  			if (urls.length >= minLength) resolve(urls);
	  		});
	  	});
	}

	async processAccount(client) { // assume client is checked (username avail etc)		
		++this.stats.attempts;

		const email = this.emailClient.emails[this.workerId];

		logId(this.workerId, `processing ${client.account.id} (${client.account.username})!`, 'yellow');

		// perform all needed tasks.
		switch (client.account.type) {
			case 'create': {
				await client.createUser(email.toString());
				break;
			}
			case 'login': {
				await client.loginUser();
				const result = await client.changeEmail(email.toString());
				if (result.data === 'banned') {
					throw new Error('banned');
				}
				break;
			}
			default:
				throw new Error('unknown entry type');
		}

		client.emit('create');
		++this.stats.created;

		// resolve emails
		logId(this.workerId, 'attempting get verify urls..', 'blue');
		const urls = await this.getVerifyUrls(client);
		if (urls.length === 0) {
			throw new Error('failed urls');
		}

		logId(this.workerId, `got verification urls for ${client.account.uid} (${client.account.id})!`, 'green');
		
		await Promise.all(urls.map((url) => client.agent.get(url, {
			[necromancerNamespace]: {
				useProxy: true // temporary solution
			}
		})));

		client.emit('verify');
		++this.stats.verified;
		logId(this.workerId, `verified ${client.account.uid}!`, 'green');

		try {
			await this.controller.mainModule(client);
		}
		catch (e) {
			console.log('mainModule error:', e);
		}

		{
			const result = await client.changeEmail();
			if (result != null && result.data === 'banned') {
				logId(this.workerId, `email proxy ban (${client.account.uid})!`, 'red');
				throw new Error('banned');
			}
		}
		logId(this.workerId, 'finished task!', 'green');

		++this.stats.finished;

		return this.stats;
	}

	async processAccounts(workerId) {
		this.workerId = workerId;

		logId(workerId, 'worker started!', 'green');

		const clientAmount = this.controller.options.clientAmount;
		while (!this.clientQueue.isEmpty()) {
			const client = this.clientQueue.dequeue();
			logId(workerId, `processing ${clientAmount - (this.clientQueue.size())}/${clientAmount}`, 'blue');

			try {
				await this.processAccount(client);
			}
			catch (error) {
				await this.onError(client, error);
			}
			finally {
				await this.doFinally(client);
			}
		}

		logId(workerId, 'worker stopped!', 'green');

		return this.stats;
	}

	async doFinally(client) {
		// unimplementated
	}

	async onError(client, error) {
		logId(this.workerId, `caught an error! ${client.account.id}`, 'yellow');
		console.log(error.message);

		switch (error.message) {
			case 'email already used': {
				logId(this.workerId, `email already used! re-enqueue ${client.account.id}`, 'yellow');
				await this.emailClient.safeGenerate(this.workerId);
				this.clientQueue.enqueue(client);
				break;
			}
			case 'failed urls': {
				logId(this.workerId, `failed urls.. ${client.account.id}`, 'red');
				try { await client.changeEmail(); } catch (error) { };
				// probably stuck in some banned/account, re-enqueue
				await this.emailClient.safeGenerate(this.workerId);
				this.clientQueue.enqueue(client);
				break;
			}
			case 'banned': {
				// skip
				logId(this.workerId, `account is banned.. ${client.account.id}`, 'yellow');
				break;
			}
			case 'username already used': {
				// unimplementated
				break;
			}
			case 'database deadlock': {
				// unimplemenated
				break;
			}
		}
	}

	constructor(options) {
		this.controller = options.controller;

		this.emailClient = this.controller.emailClient;

		this.clientQueue = this.controller.clientQueue;

		this.stats = new WorkerStats();
	}
};

// gimie elixirrrr
class FxpWorkerController {
	async start() {
		this.loadAccountData(this.options.accountFile);

		this.loadClients(this.options.clientAmount);

		log('initializing emails..', 'yellow');
		await this.emailClient.init(this.concurrency);
		log('initialized emails', 'yellow');

		const promises = Array.from({ length: this.workers.length }, (_, i) => i).map((i) => {
			return this.workers[i].processAccounts(i);
		});

		const results = await Promise.allSettled(promises);

		log('finished', 'green');
		log('collecting stats!', 'yellow');

		const final = this.collectStats(this.workers.map((worker) => worker.stats));
		this.final = final;

		log(`final: ${ require('util').inspect(final, { colors: true, depth: null }) }`, 'green');
	}

	loadAccountData(file) {
		const data = [ ];
		const raw = readFileSync(file, 'utf-8');
		const lines = raw.split('\n'); // raw.matchAll(/^(.*?):(.*?):(.*?)$/m)

		let id = 0;
		lines.forEach((line) => {
			let [ username, password, type ] = line.split(':');
			if (username && password && type) {
				username = username.trim().substring(0, 17);
				password = password.trim();
				type = type.trim();

				data.push({
					username,
					password,
					passwordHash: crypto.createHash('md5').update(password).digest('hex'),
					type,
					id: id
				});
				++id;
			}
		});

		this.accountData = data;

		this.options.clientAmount = this.options?.clientAmount ?? this.accountData.length;
		this.concurrency = Math.min(this.concurrency, this.options.clientAmount);
	}

	resetData() {
		this.accountData = [ ];
	}

	loadClients() {
		for (let i = 0; i < this.options.clientAmount; ++i) {
			const client = new Fxp(this.accountData[i]);

			this.clientSetup(client);

			this.clientQueue.enqueue(client);
		}
	}

	//getPosition(client) {
	//	return (client.id - 1) % this.concurrency;
	//}

	collectStats(result) {
		const stats = new WorkerStats();

		for (const worker of result) {
			stats.attempts += worker.attempts;
			stats.created += worker.created;
			stats.verified += worker.verified;
			stats.finished += worker.finished;
		}

		return stats;
	}

	constructor(options) {
		this.options = options;

		this.concurrency = options.concurrency;

		this.clientQueue = new AsyncClientQueue([ ]);
		//this.clientQueue = ClientQueue.fromArray(options.clients);

		this.clientSetup = options?.clientSetup ?? ((client) => { });

		this.emailClient = options.emailClient;

		this.mainModule = options.mainModule;

		this.workers = [ ];

		for (let i = 0; i < this.concurrency; ++i) {
			const worker = new FxpWorker({ controller: this });
			this.workers.push(worker);
		}
	}
};

class FxpSocketClient extends EventEmitter {
	constructor(client) {
		super();
		this.setMaxListeners(Infinity);
		assert(client, 'client expected!');

		this.client = client;
		this.agent = client.agent;

		this.received = [ ];
	}

	connect() {
		const sendString = `{"userid":"${this.sendData.uidHash}","froum":"${this.sendData.forumHash}"}`;

		this.socket = socket('https://socket5.fxp.co.il', {
			reconnection: true,
			reconnectionDelay: 1000,
			reconnectionDelayMax: 5000
		});

		this.socket.on('connect_error',console.log);
		this.socket.on('connect', () => {
			//console.log(sendString)
			this.socket.send(sendString);
		});

		this.socket.on('disconnect', () => {
			this.close();
		});

		this.socket.on('reconnect', () => {
		});

		// fxp signals
		this.socket.on('newreply', (data) => {
			//console.log('newreply', data);
			const entry = {
				...data,
				type: 'newreply'
			};

			this.emit('received', entry);
			this.received.push(entry);
		});

		this.socket.on('new_like', (data) => {
			//console.log('new_like', data);
			const entry = {
				...data,
				type: 'new_like'
			};

			this.emit('received', entry);
			this.received.push(entry);
		});

		this.socket.on('newtread', (data) => { // new thread
			//console.log('newtread', data);
			const entry = {
				...data,
				type: 'newtread'
			};

			this.emit('received', entry);
			this.received.push(entry);
		});

		this.socket.on('showthreadpost', (data) => { // post on thread
			//console.log('showthreadpost', data);
			const entry = {
				...data,
				type: 'showthreadpost'
			};

			this.received.push(entry);
			this.emit('received', entry);
		});
	}

	close() {
		if (this.socket == null) return;

		this.socket.close();

		this.socket = null;
	}

	async init(data) {
		Object.assign(this, data);

		const path = this.type === 'thread' ? 'showthread.php?t=' : 'forumdisplay.php?f=';

		const result = await this.agent.get(path + this.id, {
			[necromancerNamespace]: {
				useProxy: false
			}
		}).then((resp) => resp.data);

		const [ , uidHash, forumHash ] = /send\s*=\s*?['"]{"userid":"(\w+)","froum":"([\w-]+)"}['"]/.exec(result);
		this.sendData = { uidHash, forumHash };

		this.connect();
	}
};

class FxpForum {
	constructor(client) {
		this.client = client;
		this.agent = client.agent;

		this.sockets = [ ];
		this.forumListener = () => { };
		this.threadListener = () => { };
	}

	async getLastThreads(forumId) {
		const result = await this.agent.get(`forumdisplay.php?f=${forumId}`, {
			[necromancerNamespace]: {
				useProxy: false
			}
		}).then((resp) => resp.data);

		const posts = result.matchAll(/<a class="threadstatus"(?:(?!#2675ad).)*?href="showthread\.php\?t=(\d+)(?:"|&amp|&)/gms); // only non-pinned threads
		
		const results = [ ];
		for (const [ , threadId ] of posts) {
			results.push({ threadId });
		}
		return results;
	}

	defaultThreadListener(data) {
		if (data.type === 'newtread') {
			this.addThreadSocket(data.id);
		}
	}

	defaultForumListener(data) {
		// unimplemented
	}

	configureSocket(socket) {
		socket.on('received', this.defaultForumListener.bind(this));
		socket.on('received', this.defaultThreadListener.bind(this));

		switch (socket.type) {
			case 'forum': {
				socket.on('received', this.forumListener);
				break;
			}
			case 'thread': {
				socket.on('received', this.threadListener);
				break;
			}
			default: {
				throw new Error('invalid socket type');
			}
		}
	}

	destroy() {
		for (let i = 0; i < sockets.length; ++i) {
			sockets[i].close();
			sockets[i] = null;
		}
	}

	async addThreadSocket(threadId) {
		const socket = new FxpSocketClient(this.client);
		await socket.init({ type: 'thread', id: threadId });
		this.configureSocket(socket);
		this.sockets.push(socket);
	}

	async init(data) {
		Object.assign(this, data);

		const results = await this.getLastThreads(this.forumId);
		this.numSockets = this.numSockets ?? results.length;
		assert(this.numSockets <= results.length, 'sockets must be not greater than threads');

		const socket = new FxpSocketClient(this.client);
		await socket.init({ type: 'forum', id: this.forumId });
		this.configureSocket(socket);
		this.sockets.push(socket);

		for (let i = 0; i < this.numSockets; ++i) {
			await this.addThreadSocket(results[i].threadId);
		}
	}
};

module.exports = {
	FxpWorkerController,
	Fxp,
	FxpImageUploader,
	FxpApiWrapper,
	Gmailnator,
	GmailnatorRefresher,
	GmailnatorMessages,
	GmailnatorClient,
	//SmailPro,
	FxpClient,
	BaseClient,
	BasicCookieJar,
	AgentPool,
	FxpHttpsProxyAgent,
	FxpSocksProxyAgent,
	FxpForum
};
